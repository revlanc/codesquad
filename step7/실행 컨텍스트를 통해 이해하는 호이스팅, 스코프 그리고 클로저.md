# 실행 컨텍스트를 통해 이해하는 호이스팅, 스코프 그리고 클로저

## 들어가며

이 글은 클로저를 처음 접하면서 느낀 의문점을 해결하기 위해 공부한 내용을 정리한 글입니다.  
실행 컨텍스트에 대해 간단히 살펴보고 이를 통해 클로저를 이해해볼거에요  
Execution Context 혹은 실행 문맥이라고 부르는 것이 맞겠지만 실행 컨텍스트라고도 흔히 사용되니 이 글에서는 실행 컨텍스트로 통일하였습니다.  
쉽게 이해하기 위해 실제 ECMA Script의 스펙에서 많은 부분을 생략하였으니 참고바랍니다 :)

## ...???

```javascript
for (var i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 1000);
}
```

여러분은 위 코드의 결과를 예상할 수 있으신가요?

```javascript
for (let i = 0; i < 5; i++)
  setTimeout(() => console.log(i), 1000);
}
```

그럼 이 코드는 어떤가요?

저는 이 두 코드의 결과를 보고 이해할 수가 없었는데요, 실행 결과는 다음과 같습니다.

![as](https://user-images.githubusercontent.com/42905468/57912587-a5f99b00-78c5-11e9-819b-0dc9d65d2bbc.png)

네.. var를 사용한 코드는 5가 5번 출력이 되고 let을 사용한 코드는 0부터 4까지 순서대로 출력이 되었네요  
대체 왜 이런 결과가 나온걸까요?  
let이 블록레벨 스코프라서?  
음.. 블록레벨 스코프라는 단어만으로는 이 현상을 이해하기엔 부족합니다.  
var를 사용한 코드에서 0부터 4까지의 숫자는 어디로 가버린 걸까요?  
코드를 실행하는 과정에서 변수는 어디에 저장되고 어떻게 참조되는 걸까요?  
이러한 실행과정을 이해하기 위해서는 실행 컨텍스트에 대한 이해가 필요합니다.

## 실행 컨텍스트란?

실행 컨텍스트는 '실행 가능한 코드'가 실행되기 위한 '환경'입니다.  
자바스크립트 엔진이 전역 코드나 함수 코드를 실행하기 위해서 필요한 환경이지요.

조금 더 쉽게 말하면, 함수를 실행하는데 필요한 변수가 기록된 객체입니다.  
자바스크립트 엔진은 코드를 읽어가며 실행에 필요한 변수를 객체에 저장합니다.  
이렇게 만들어진 객체(환경)에서 실행에 필요한 변수들을 찾으면서 코드를 실행하는 것이지요.

자바스크립트 엔진은 전역 코드, 함수 코드를 만날 때마다 새로운 실행 컨텍스트를 생성합니다.

## 실행 컨텍스트 스택

실행 컨텍스트 스택은 '콜스택'이라고도 알려져있는데요, 생성된 실행 컨텍스트가 쌓이는 곳입니다.  
생성 된 순서대로 스택에 차례대로 쌓이고, 실행이 완료되면 스택에서 제거됩니다.

```javascript
function foo() {
  const a = 20;
  function bar() {
    const b = 30;
    console.log(a + b);
  }
}
foo();
```

위와 같은 코드를 실행했을 때, 실행 컨텍스트 스택의 변화는 아래 그림과 같습니다.

![실행 컨텍스트 스택](https://poiemaweb.com/img/ec_1.png)
(이미지출처 : [포이에마웹](https://poiemaweb.com/js-execution-context))

## 실행 컨텍스트의 구성

실행 컨텍스트는 몇가지 컴포넌트로 구성됩니다.  
그 중 우리가 주목해야할 것은 Lexical Environment라는 컴포넌트입니다.  
Lexical Environment는 식별자가 기록되는 Environment Record와 상위 Lexical Environment를 참조하는 Outer Environment Reference로 구성됩니다.  
이를 pseudo code로 작성하면 아래와 같은 형태를 가집니다.

```javascript
Execution Context = {
  Lexical Environment: {
    Environment Record: {
      //식별자(변수명 & 함수명)들이 여기 기록됩니다.
    },
    Outer Environment Reference: <ref. to outer Environment>
  }
};
```

## 실행 컨텍스트의 2가지 phase

실행 컨텍스트는 2가지 phase로 나눠서 보면 조금은 이해가 쉽습니다.  
각 단계별로 실행 컨텍스트에 어떤 변화가 생기는지 아래 예제코드를 통해 살펴보겠습니다.

```javascript
var a = "a";
let b = "b";
function sum(x, y) {
  return x + y;
}
const foo = function() {
  console.log("foo");
};
```

### 1. Creation phase

첫번째 단계는 실행 컨텍스트를 생성하고 초기화하는 단계입니다.  
이 단계에서는 3가지 작업이 이루어집니다.

```
1. 전역코드나 함수코드를 만나면, 새 실행 컨텍스트를 만듭니다.
2. 매개변수와 선언문을 평가하여 Environment Record에 기록합니다.
3. Outer Environment Reference를 설정합니다.
```

Environment Record에 기록하는 순서는 아래와 같습니다.

```
1. (함수코드의 경우) 매개변수를 property로, 인수를 value로 기록한다.
2. 함수 선언문의 함수명을 property로, 생성된 함수 객체를 value로 기록한다.
3. 변수 선언문의 변수명을 property로 기록하고, var로 선언된 경우 value로 undefined를 기록한다.
  (let과 const는 값을 저장하지 않은채로 둔다)
```

Outer Environment Reference에는 현재 실행 컨텍스트 스택의 최상단에 있는 실행 컨텍스트의 Lexical Environment 참조값을 설정합니다.

생성 단계를 마친 전역 실행 컨텍스트를 pseudo code로 표현하면 다음과 같습니다.

```javascript
Global Execution Context = {
  Lexical Environment : {
    Environment Record : {
      sum : <function>,
      a : undefined,
      b : //초기화되지 않음,
      foo : //초기화되지 않음
    },
    Outer Environment Reference : null
  }
}
```

### 2. Execution phase

두번째 단계는 코드를 실행하는 단계입니다.  
이 단계에서는 '할당', '연산', '함수호출'을 평가합니다.  
line by line으로 코드를 읽어가며 '할당', '연산', '함수호출' 을 만나면 해당 작업을 실행합니다.

실행 단계를 마친 컨텍스트를 pseudo code로 표현하면 다음과 같습니다.

```javascript
Global Execution Context = {
  Lexical Environment : {
    Environment Record : {
      sum : <function>,
      a : 'a',
      b : 'b',
      foo : <function>
    },
    Outer Environment Reference : null
  }
}
```

## 호이스팅

여기서 잠깐 예제 코드를 다시 봅시다.

```javascript
//console.log(a);
//sum(10, 20);
//console.log(b);
//foo();
var a = "a";
let b = "b";
function sum(x, y) {
  return x + y;
}
const foo = function() {
  console.log("foo");
};
```

실행 컨텍스트가 생성 단계를 마치고 실행 단계로 넘어갔다고 생각해봅시다.  
만약 주석 처리한 코드가 주석이 아니라면 해당 코드는 실행 단계에서 실행됩니다.  
이 시점에서는 아직 '할당', '연산' 등의 작업이 이루어지지 않은 상태입니다.

이 때, 자바스크립트 엔진이 `console.log(a)`을 만나면 변수 a를 현재 Lexical Environment 에서 찾습니다.  
이 시점에서 var로 선언한 변수 a는 undefined로 초기화 되어있고 아직 'a'로 할당되지 않은 상태입니다.  
그러므로 콘솔에 undefined를 출력합니다.  
이것이 바로 호이스팅입니다.

두번째 주석 역시 마찬가지입니다.  
이 시점에서 function으로 선언한 식별자 sum은 함수객체를 참조하고 있기 때문에 해당 함수를 실행해서 값을 리턴합니다.

이제 세번째 주석을 봅시다.  
이 시점에서 let으로 선언한 변수 b는 초기화 되지 않은 상태로, 값에 아무것도 할당되어있지 않습니다.  
따라서 `console.log(b)`는 `Reference Error`를 출력합니다.  
이것은 바로 TDZ라고 부르는 개념입니다.

이번에는 네번째 주석을 봅시다.  
이 시점에서 const로 선언한 변수 foo는 초기화 되지 않은 상태로, 값에 아무것도 할당되어있지 않습니다.  
따라서 `foo()`는 `Reference Error`를 출력합니다.

### 호이스팅 정리

실행 컨텍스트는 생성 단계에서 선언문의 종류에 따라 값을 초기화합니다.  
이 후 실행 단계에서 식별자에 접근하면 Lexical Environment에서 값을 찾습니다.  
할당 이전에 식별자에 접근하더라도 var나 function으로 선언된 식별자는 초기화된 값에 접근이 가능합니다.  
반면 let과 const로 선언된 식별자는 할당되기 이전에는 초기화되지 않기 때문에 값에 접근이 불가능합니다.

즉, 호이스팅은 실행 컨텍스트가 생성 단계에서 식별자를 초기화하는 과정에서 발생하는 현상이라고 할 수 있습니다.

## 예시 코드

아래와 같은 코드를 실행했을 때 실행 컨텍스트가 생성되는 과정을 단계별로 살펴보겠습니다.

```javascript
const x = "x";
function sum(a, b) {
  var result = a + b;
  let bar = function() {
    console.log("bar");
  };
  function printResult() {
    console.log(result);
  }
  return result;
}

sum(10, 20);
```

### 1. Global Execution Context 생성

우선 스크립트가 실행되면 전역 실행 컨텍스트를 생성합니다.  
그리고 전역에 존재하는 식별자를 Environment Record에 등록합니다.


```javascript
function makeCounter() {
  let count = 0;
  return function() {
    return count++;
  };
}
const counter1 = makeCounter();
const counter2 = makeCounter();
console.log(counter1());
console.log(counter2());
console.log(counter1());
console.log(counter2());
```

## 참고자료

- https://www.ecma-international.org/ecma-262/9.0/
- https://poiemaweb.com/js-execution-context
- https://huns.me/development/1407
- https://meetup.toast.com/posts/129
- https://velog.io/@imacoolgirlyo/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-Hoisting-The-Execution-Context-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-6bjsmmlmgy
